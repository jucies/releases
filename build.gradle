buildscript {
    repositories {
        jcenter()
        maven { url "https://jitpack.io" }
    }

    dependencies {
        classpath 'com.github.yandex-qatools:juseppe:v1.0.0'
        classpath 'com.vdurmont:semver4j:2.0.1'
        classpath 'org.ajoberstar:grgit:1.6.0'
    }
}

plugins {
    id "base"
}

repositories {
    jcenter()
    maven { url "https://jitpack.io" }
    maven { url "https://repo.jenkins-ci.org/public" }
}

configurations {
    plugin {
        transitive = false
    }
}

def githubToken = System.getenv('GH_TOKEN')

void logErrorOrFail(text) {
    def pullRequestEnv = System.getenv("TRAVIS_PULL_REQUEST")
    def isMasterBuild = !pullRequestEnv || "false".equalsIgnoreCase(pullRequestEnv)

    if (isMasterBuild) {
        services.get(org.gradle.logging.StyledTextOutputFactory).create("Jucies").withStyle(org.gradle.logging.StyledTextOutput.Style.Failure).println(text)
    } else {
        throw new GradleException(text)
    }
}

def pluginsById = [:]

// Index plugins
file("plugins").eachFile {
    if (!it.name.endsWith(".properties")) {
        throw new GradleException("'.properties' file extension was expected, but got: ${it}")
    }

    def properties = new Properties()
    it.withInputStream(properties.&load)

    def repository = properties.repository as String
    def module = properties.module
    def parts = repository?.split("/", 2)

    if (parts?.length != 2) {
        throw new GradleException("Wrong format of 'repository' property! 'org/repo' was expected, but got '${repository}' in ${it}")
    }

    final def groupId
    final def artifactId

    def owner = parts[0]
    def repoName = parts[1]
    if (module) {
        groupId = "com.github.${owner}.${repoName}"
        artifactId = module
    } else {
        groupId = "com.github.${owner}"
        artifactId = repoName
    }

    def pluginId = it.name - '.properties'

    if (!properties.version && properties.tag) {
        throw new GradleException("'tag' property must not be used without 'version' property.")
    }

    String version = properties.version
    String tag = properties.tag ?: version

    pluginsById[pluginId] = [
            name: pluginId,
            version: version,
            tag    : tag,
            repository: repository,
            groupId: groupId,
            artifactId: artifactId,
            owner: owner,
            repoName: repoName
    ]
}

// Resolve version/tag if not set
if (githubToken) {
    def queryIdCounter = 0
    def queryIdToDescription = pluginsById.values().findAll { !it.version }.collectEntries {
        ["i${queryIdCounter++}".toString(), it]
    }

    def queryText = '''
fragment latestReleaseTag on Repository {
  releases(last: 1) {
    edges {
      node {
        tag {
          name
        }
      }
    }
  }
}
{
'''

    queryIdToDescription.forEach { queryId, description ->
        queryText += """
    ${queryId}:repository(owner: "${description.owner}", name: "${description.repoName}") { ...latestReleaseTag }
"""
    }

    queryText += "}"

    def baseUrl = new URL("https://api.github.com/graphql?access_token=${githubToken}")
    def connection = baseUrl.openConnection()
    connection.with {
        doOutput = true
        requestMethod = 'POST'
        outputStream.withWriter { writer ->
            writer << (new groovy.json.JsonBuilder(query: queryText)).toString()
        }
        def result = new groovy.json.JsonSlurper().parseText(content.text)

        result.data.forEach { queryId, releaseInfo ->
            def description = queryIdToDescription[queryId]
            description.version = description.tag = releaseInfo?.releases?.edges?.first()?.node?.tag?.name
        }
    }
} else {
    pluginsById.each { pluginId, description ->
        def repository = description.repository

        if (!description.version) {
            try {
                def latestRelease = new groovy.json.JsonSlurper().parse("https://api.github.com/repos/${repository}/releases/latest".toURL())
                description.version = description.tag = latestRelease.tag_name
            } catch (Exception e) {
                logErrorOrFail("Failed to get the latest release of ${repository}")
                return
            }
        }
    }
}

pluginsById.each { pluginId, description ->
    def version = description.version
    def repository = description.repository

    def pluginPrefix = "${pluginId}-"
    if (version.startsWith(pluginPrefix)) {
        version = version.substring(pluginPrefix.length())
    }

    if (version.startsWith("v")) {
        version = version.substring(1)
    }

    logger.info("Latest release of {}: {}", repository, version)

    description.version = version
}

// Validate versions
pluginsById.each { pluginId, description ->
    def version = description.version

    if (!version?.trim()) {
        throw new GradleException("'version' property can't be empty, but it is so in ${pluginId}")
    }

    try {
        new com.vdurmont.semver4j.Semver(version, com.vdurmont.semver4j.Semver.SemverType.LOOSE);
    } catch (com.vdurmont.semver4j.SemverException e) {
        logErrorOrFail("${description.repository} has non-semantic version: ${e.message}")
        return
    }
}

def gavToId = [:]
pluginsById.each { pluginId, description ->
    gavToId["${description.groupId}:${description.artifactId}:${description.tag}".toString()] = pluginId
}

gavToId.each { gav, description -> dependencies.add("plugin", gav) }

import com.google.gson.JsonObject
import com.google.gson.JsonSerializer
import org.ajoberstar.grgit.Grgit
import ru.lanwen.jenkins.juseppe.beans.UpdateSite
import ru.lanwen.jenkins.juseppe.beans.Plugin
import ru.lanwen.jenkins.juseppe.gen.HPI
import ru.lanwen.jenkins.juseppe.util.PluginListSerializer
import com.google.gson.GsonBuilder

def updateCenterFileName = "update-center.json"
def updateCenterFile = project.file("${project.buildDir}/${updateCenterFileName}")
task generate << {
    def site = new UpdateSite(
            id: "jucies",
            updateCenterVersion: 1,
            plugins: configurations.plugin.resolvedConfiguration.resolvedArtifacts.collect {
                def identifier = it.moduleVersion.id

                def gav = "${identifier.group}:${identifier.name}:${identifier.version}"

                def desc = pluginsById[gavToId[gav.toString()].toString()]

                return HPI.loadHPI(it.file)
                        .withName(desc.name)
                        .withVersion(desc.version)
                        .withUrl("https://jitpack.io/${identifier.group.replace(".", "/")}/${identifier.name}/${identifier.version}/${identifier.name}-${identifier.version}.hpi")
            }
    )

    JsonSerializer<List<Plugin>> pluginListSerializer = { plugins, type, context ->
        return plugins.sort { it.name }.inject(new JsonObject()) { result, plugin ->
            result.add(plugin.name, context.serialize(plugin))
            return result
        }
    }

    def gson = new GsonBuilder()
            .registerTypeAdapter(PluginListSerializer.PLUGIN_LIST_TYPE, pluginListSerializer)
            .disableHtmlEscaping()
            .setPrettyPrinting()
            .create()

    def result = String.format("updateCenter.post(%n%s%n);", gson.toJson(site))

    updateCenterFile.parentFile.mkdirs()
    updateCenterFile.delete()

    updateCenterFile << result
}

task publishGhPages << {
    def dir = "${project.buildDir}/ghpages"

    file(dir).deleteDir()

    final def credentials
    if (githubToken) {
        println "GitHub token is set. Will use it as credentials"
        credentials = new org.ajoberstar.grgit.Credentials(githubToken, '')
    } else {
        credentials = null
    }

    def repo = Grgit.clone(
            uri: 'https://github.com/jucies/jucies.github.io.git',
            refToCheckout: 'master',
            dir: dir,
            credentials: credentials
    )

    project.copy {
        from updateCenterFile
        into dir
    }

    repo.with {
        if (!status().isClean()) {
            println "Commiting changes..."
            commit(message: "Publish of Github pages from Gradle.", paths: [updateCenterFileName])
            push()
        }
    }
}
